
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>wanderlust-booking-elegance</title>
    <meta name="description" content="Lovable Generated Project" />
    <meta name="author" content="Lovable" />

    <meta property="og:title" content="wanderlust-booking-elegance" />
    <meta property="og:description" content="Lovable Generated Project" />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="https://lovable.dev/opengraph-image-p98pqg.png" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@lovable_dev" />
    <meta name="twitter:image" content="https://lovable.dev/opengraph-image-p98pqg.png" />
  </head>

  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
    
    <!-- Improved Badge Removal Script -->
    <script>
      // Function to safely remove Lovable badge
      function removeLovableBadge() {
        try {
          // Only target specific lovable badge elements
          const badgeById = document.getElementById('lovable-badge');
          if (badgeById && badgeById.href && badgeById.href.includes('lovable.dev')) {
            badgeById.remove();
            console.log('Lovable badge removed by ID');
          }
          
          // Remove links that specifically point to lovable.dev
          const lovableLinks = document.querySelectorAll('a[href*="lovable.dev"]');
          lovableLinks.forEach(link => {
            try {
              // Only remove if it contains the edit text or lovable badge specific content
              if (link.textContent && (
                link.textContent.includes('Edit with') || 
                link.id === 'lovable-badge' ||
                link.innerHTML.includes('lovable')
              )) {
                link.remove();
                console.log('Lovable badge link removed');
              }
            } catch (e) {
              // Silently handle any errors with individual elements
            }
          });
          
        } catch (error) {
          // Silently handle errors to prevent breaking the app
          console.warn('Badge removal error (non-critical):', error.message);
        }
      }
      
      // Run after React has mounted
      setTimeout(() => {
        removeLovableBadge();
      }, 1000);
      
      // Create a more conservative MutationObserver
      const observer = new MutationObserver((mutations) => {
        let shouldCheck = false;
        
        try {
          mutations.forEach((mutation) => {
            if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
              mutation.addedNodes.forEach((node) => {
                if (node.nodeType === 1 && node.id === 'lovable-badge') {
                  shouldCheck = true;
                }
              });
            }
          });
          
          if (shouldCheck) {
            setTimeout(removeLovableBadge, 500);
          }
        } catch (error) {
          // Silently handle observer errors
        }
      });
      
      // Start observing only after React has had time to mount
      setTimeout(() => {
        try {
          if (document.body) {
            observer.observe(document.body, {
              childList: true,
              subtree: true
            });
          }
        } catch (error) {
          console.warn('Observer setup error (non-critical):', error.message);
        }
      }, 2000);
      
      console.log('Improved badge removal script initialized');
    </script>
  </body>
</html>
